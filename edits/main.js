"use strict";

// Counter to generate unique identifiers for edits/rows
let LAST_EDIT_ID = 0;
// Array of data extracted from each uploaded simfile, containing charts, song title, etc.
let SIMFILES = [];

// Highlight a UI element to show users where a problem has occurred. Also highlight the number of the row
//
// editId: The unique identifier for the row/edit with the problem
// field: The specific field which is to be highlighted (use the FIELD_* consts)
function highlightField(editId, field) {
	let obj;
	if (field === FIELD_SONGID) {
		obj = document.getElementById("song" + editId);
	} else if (field === FIELD_STEPSTYPE) { 
		obj = document.getElementById("chart" + editId);
	} else if (field === FIELD_DIFFICULTY) {
		obj = document.getElementById("difficulty" + editId);
 	} else if (field === FIELD_METER) {
		obj = document.getElementById("meter" + editId);
	} else if (field === FIELD_COMMENTA) {
		obj = document.getElementById("commenta" + editId);
	} else if (field === FIELD_COMMENTB) {
		obj = document.getElementById("commentb" + editId);
	} else if (field === FIELD_EDITNAME) {
		obj = document.getElementById("editname" + editId);
	} else if (field === FIELD_NOTES) {
		obj = document.getElementById("chart" + editId);
	}
	let num = document.getElementById("num" + editId);

	num.classList.add("problem");
	if (obj) obj.classList.add("problem");
}

// Add a message (without any special formatting) to the messages area
function addMessage(m) {
	let msg = document.getElementById("message");
	if (msg.innerHTML.includes(m)) {
		return;
	}
	if (msg.innerHTML !== "") {
		msg.innerHTML += "<br/>";
	}
	m = m.replaceAll("&", "&amp;");
	m = m.replaceAll("<", "&lt;");
	m = m.replaceAll("\n", "<br/>\n");
	m = m.replaceAll("  ", "&nbsp;&nbsp;&nbsp;&nbsp;");
	msg.innerHTML += m;
}

// Format an error message and log it to the messages area; also highlight the UI element most associated with the error
//
// editId: The unique identifier for the row/edit associated with the error, or 0 if none apply
// field: An identifier for the field associated with the error, if applicable (use the FIELD_* consts)
// err: The error string to display
// prefix: The type of error, visually indicated by an emoji in the messages area (use the PREFIX_* consts)
function addError(editId, field, err, prefix = PREFIX_UNKNOWN) {
	let msg = `${prefix} `;
	if (editId > 0) {
		// Get the number of the row as displayed on screen
		let displayId = "ERR";
		for (let i = 0; i < SIMFILES.length; i++) {
			if (SIMFILES[i].editId === editId) {
				displayId = `${i+1}`;
				break;
			}
		}
		msg += `[Edit #${displayId}] `;
	}
	msg += err;
	addMessage(msg);
	if (editId > 0) {
		highlightField(editId, field);
	}
}

// Clear the messages area and remove the error highlights on UI elements
function clearErrors() {
	document.getElementById("message").innerHTML = "";

	const prefixes = ["song", "chart", "difficulty", "meter", "commenta", "commentb", "editname", "num"];
	for (let i = 0; i < SIMFILES.length; i++) {
		for (let j = 0; j < prefixes.length; j++) {
			let id = SIMFILES[i].editId;
			let elem = document.getElementById(prefixes[j] + id);
			if (elem) {
				elem.classList.remove("problem");
			}
		}
	}
}

// Search a string for a tag in the SSC/SM file format; if it exists, return its content; otherwise return null
//
// Examples:
// getTag("#TAG:a;#TAG:b;#TAG:c;", "TAG") -> "a"
// getTag("#TAG:a;#TAG:b;#TAG:c;", "TAG", 1) -> "b"
// getTag("#TAG:a;#TAG:b;#TAG:c;", "TAG", 7) -> "b"
// getTag("#TAG:a;#TAG:b;#TAG:c;", "TAG", 8) -> "c"
// getTag("blahblah\n#TEST:3:4:5;\nblahblah", "TEST") -> "3:4:5"
//
// contents: The string to search through for a tag
// name: The name of the tag for search for
// idx: The byte position to start searching from
//
// NOTE: This tag parsing logic is incomplete and likely differs from Stepmania's in several ways
// Escaped semicolons are not taken into consideration. It assumes comments are stripped
// However, it should be good enough to handle mostly any chart generated by Stepmania that would be appropriate for use with this converter tool (no song titles in DDR X2 have a semicolon)
function getTag(contents, name, idx = 0) {
	let i = contents.indexOf(`#${name}:`, idx);
	if (i === -1) {
		return null;
	}
	let j = contents.indexOf(";", i);
	// If there is no semi-colon, pretend the tag content ends at the end of the string?
	// TODO: Check if this is the right thing to do (this edge case should never happen)
	if (j === -1) {
		j = contents.length;
	}
	return contents.substring(i + name.length + 2, j);  // The `+2` accounts for the `#` and `:` characters
}

// Extract the charts from the contents of an SM or SSC file
//
// Return an array of {chartName, stepsType, difficulty, meter, notes} objects
function readCharts(contents) {
	let charts = [];
	let idx = 0;

	if (contents.indexOf("#NOTEDATA:") !== -1) { // SSC format
		while (idx < contents.length) {
			let i = contents.indexOf("#NOTEDATA:", idx);
			let next = contents.indexOf("#NOTEDATA:", i + 1);
			if (next === -1) {
				next = contents.length;
			}
			let notedata = contents.substring(i, next);

			let chartName = getTag(notedata, "CHARTNAME");
			let stepsType = getTag(notedata, "STEPSTYPE");
			let difficulty = getTag(notedata, "DIFFICULTY");
			let meter = getTag(notedata, "METER");
			let notes = getTag(notedata, "NOTES");

			if (notes !== null) {
				if (stepsType === "dance-single" || stepsType === "dance-double") {
					if (chartName === null) { chartName = ""; }
					if (difficulty === null) { difficulty = "Unknown"; }
					if (meter === null) { meter = "0"; }
					let meterNum = parseInt(meter, 10);

					charts.push({
						"chartName": chartName,
						"stepsType": stepsType,
						"difficulty": difficulty,
						"meter": meterNum,
						"notes": notes,
					});
				}
			}
			
			idx = next;
		}
	} else { // If not SSC, assume SM 3.95 format
		while (idx < contents.length) {
			let i = contents.indexOf("#NOTES:", idx);
			if (i === -1) {
				break;
			}
			let buf = getTag(contents, "NOTES", i);
			if (buf !== null) {
				let sections = buf.split(":");
				if (sections.length === 6) {
					let stepsType = sections[0].trim();
					let chartName = sections[1].trim();
					let difficulty = sections[2].trim();
					let meter = sections[3].trim();
					let radar = sections[4].trim();  // No use for this
					let notes = sections[5];

					if (stepsType === "dance-single" || stepsType === "dance-double") {
						if (meter === "") { meter = "0"; }
						let meterNum = parseInt(meter, 10);
						charts.push({
							"chartName": chartName,
							"stepsType": stepsType,
							"difficulty": difficulty,
							"meter": meterNum,
							"notes": notes,
						});
					}
				}
			}
			idx = i + 1;
		}
	}

	return charts;
}

// Remove any comments from a string; also remove leading/trailing whitespace
function stripComments(contents) {
	let lines = contents.split(/\r?\n/);
	for (let i = 0; i < lines.length; i++) {
		let j = lines[i].indexOf("//");
		if (j === -1) continue;
		lines[i] = lines[i].substring(0, j).trim();
	}
	return lines.join("\r\n");
}

// Extract information from the contents of an SM or SSC file
//
// Return an array of {editId, fileName, title, charts} objects
// See `readCharts` for information about `charts`
// Note that `title` can be null
function readSimfile(fileName, contents) {
	contents = stripComments(contents);

	let title = getTag(contents, "TITLE", 0);
	let charts = [];
	if (title !== null) {
		charts = readCharts(contents);
	}
	LAST_EDIT_ID++;

	return {
		"editId": LAST_EDIT_ID,
		"fileName": fileName,
		"songName": title,
		"charts": charts,
	};
}

// Disable or enable the "Create Edit" and "Upload .SM/.SSC Files" buttons, depending on the number of files currently uploaded
function updateButtons() {
	document.getElementById("cbutton").disabled = (SIMFILES.length <= 0);
	document.getElementById("upload").disabled = (SIMFILES.length >= MAX_FILES);
}

// Calculate the Levenshtein distance between two words
//
// The Levenshtein distance is the minimum number of insertions, deletions, and substitutions to get from one word to another
// For example: levenshtein("WAITER", "HATERS") is 3: Subsitute W->H, Delete I, Insert S
// 
// We can solve this with dynamic programming. First we initialize a 2D array like this (we'll call it dp):
//
//      H A T E R S
//   [0 1 2 3 4 5 6]
// W [1 0 0 0 0 0 0]
// A [2 0 0 0 0 0 0]
// I [3 0 0 0 0 0 0]
// T [4 0 0 0 0 0 0]
// E [5 0 0 0 0 0 0]
// R [6 0 0 0 0 0 0]
//
// Once the algorithm is complete, each cell in the array will represent how many operations are required to get from one part of the word to one part of the other.
// Formally, dp[i][j] will be the minimum number of operations to get from word1.substring(0,i) to word2.substring(0,j)
// For example, dp[2][3] will be the minimum number of operations to get from "WA" to "HAT"
//
// We start with the first row and column already filled out
// For example, dp[0][2] is 2 because it takes two insertions to get from "" to "HA"
// Similarly, dp[4][0] is 4 because it takes four deletions to get from "WAIT" to ""
//
// When filling out a new cell, we'll consider each situation where the final operation we perform to get from one word to the other is 1) insertion, 2) deletion, or 3) substitution
//
// Also, when filling out cell dp[i][j], we will maintain the invariants that:
//   1) Cells dp[a][b] (where a < i, b < j) will already be filled out, and
//   2) Cells dp[a][b] (where a < i, b < j) will contain the minimum number of operations to get from word1.substring(0,a) to word2.substring(0,b)
// This means we must fill out cells in a top-left to bottom-right order
//
// For illustrative purposes, we'll consider dp[3][3] (a.k.a. the distance from "WAI" to "HAT") as an example
//
// Insertion:
// Consider the case where insertion is our final operation to get from "WAI" to "HAT"; this means adding "T" is the final operation, as "T" is the last character of "HAT"
// This is just one operation more than the number of operations to get from "WAI" to "HA"
// But due to our invariant, we already know the minimum number of operations to get from "WAI" to "HA"; that is what dp[3][2] represents
// Generally, if insertion is the final operation from word1.substring(0,i) to word2.substring(0,j), it can be done in (dp[i][j-1] + 1) operations
//
// Deletion:
// Consider the case where deletion is our final operation to get from "WAI" to "HAT"; this means deleting "I" is the final operation, as "I" is the last character of "WAI"
// This is just one operation more than the number of operations to get from "WA" to "HAT"
// But due to our invariant, we already know the minimum number of operations to get from "WA" to "HAT"; that is what dp[2][3] represents
// Generally, if deletion is the final operation from word1.substring(0,i) to word2.substring(0,j), it can be done in (dp[i-1][j] + 1) operations
//
// Substituion:
// Consider the case where substitution is our final operation to get from "WAI" to "HAT"; this means substituting "I" for "T" is the final operation, as these are the final letters of each word
// Since "I" and "T" are different letters, this is just one operation more than the number of operations to get from "WA" to "HA"
// However, the final letters of each word had been the same, we would not need to add an operation
// For example, it takes the exact same number of operations to get from "CAT" to "DOG" as it does to get from "CATS" to "DOGS"
// Therefore, if substitution is the final operation from word1.substring(0,i) to word2.substring(0,j), it can be done in:
//   (dp[i-1][j-1] + 1) operations if the ith character of word1 does not equal the jth character of word2, or
//   (dp[i-1][j-1]) operations if the ith character of word1 equals the jth character of word2
//
// Finally, after considering each of these three cases, the minimum number of operations is simply the case that produced the fewest number of operations;
// That is to say, dp[i][j] === Math.min(dp[i][j - 1] + 1, dp[i - 1][j] + 1, dp[i - 1][j - 1] + (word1[i - 1] !== word2[j - 1))
//
//      H A T E R S
//   [0 1 2 3 4 5 6]
// W [1 1 2 3 4 5 6]
// A [2 2 1 2 3 4 5]
// I [3 3 2 2 3 4 5]
// T [4 4 3 2 3 4 5]
// E [5 5 4 3 2 3 4]
// R [6 6 5 4 3 2 3]
//
// After filling out the whole array, the bottom-right cell shows the minimum number of operations to move from word1 to word2
function levenshtein(word1, word2) {
	let dp = [];
	for (let i = 0; i < word1.length + 1; i++) {
		let r = [];
		for (let j = 0; j < word2.length + 1; j++) {
			r.push(0);
		}
		dp.push(r);
	}

	for (let i = 0; i <= word1.length; i++) {
		dp[i][0] = i;
	}

	for (let i = 0; i <= word2.length; i++) {
		dp[0][i] = i;
	}

	for (let i = 1; i <= word1.length; i++) {
		for (let j = 1; j <= word2.length; j++) {
			let curDiff = 0;
			if (word1[i - 1] !== word2[j - 1]) {
				curDiff = 1;
			}
			let insertion    = dp[i][j - 1] + 1;
			let deletion     = dp[i - 1][j] + 1;
			let substitution = dp[i - 1][j - 1] + curDiff;

			dp[i][j] = Math.min(insertion, deletion, substitution);
		}
	}

	return dp[word1.length][word2.length];
}

// Given the title of a song, find the id of the song with the closest-matching name.
// Not all simfiles have the exact same titles as those used in DDR; the goal is to be able to match even with minor differences
// For example, "AFRONOVA (X-Special)" should match the official title of "AFRONOVA(X-Special)"
function findSongMatch(songName) {
	// The official song titles use wide tildes; some simfile titles use normal tildes
	songName = songName.replaceAll("~", "～").toUpperCase();

	let bestDiff = 1e9;
	let bestId = -1;
	for (let i = 0; i < ALL_SONGS.length; i++) {
		for (let j = 0; j < ALL_SONGS[i].names.length; j++) {
			let diff = levenshtein(songName, ALL_SONGS[i].names[j].toUpperCase());
			if (diff < bestDiff) {
				bestDiff = diff;
				bestId = ALL_SONGS[i].id;
			}
		}
	}
	return bestId;
}

// Create a song-selection dropdown element with a specific song title pre-selected
//
// songName: The title of a song, as specified by an SM/SSC file. The closest-matching song name will be selected
// editId: The unique identifier for this row/edit
function createSongSelect(songName, editId) {
	let select = document.createElement("SELECT");
	select.id = "song" + editId;
	select.className = "songselect";
	select.title = "Select the song to play for this edit.  This field is auto-populated based on a guess from the simfile's #TITLE tag.  If the song you want isn't in this list, it isn't available.";

	let songId = findSongMatch(songName);

	for (let i = 0; i < ALL_SONGS.length; i++) {
		let option = document.createElement("OPTION");
		option.value = ALL_SONGS[i].id;
		option.text = ALL_SONGS[i].names[0];
		if (songId === ALL_SONGS[i].id) {
			option.selected = true;
		}
		select.appendChild(option);
	}

	return select;
}

// Convert a name to one that is displayable in-game
//
// This means excluding non-printable characters and keeping a max of 8 characters
// Do not pad spaces at the end; the user shouldn't have to worry about those
//
// TODO: There are several other characters that are acceptable here; I extracted the font image so I can add them at some point. For now, these are fine.
function formatEditName(name) {
	return name.toUpperCase().trim().replaceAll(/[^A-Z0-9 \!\@\#\$\%\&\-\_\=\+\(\)\\\.]/g,"").substring(0, 8).trim();
}

// Create a chart-selection dropdown element
//
// charts: An array of objects containing parsed chart information (see: readCharts)
// editId: The unique identifier for this row/edit
function createChartSelect(charts, editId) {
	let select = document.createElement("SELECT");
	select.id = "chart" + editId;
	select.className = "chartselect";
	select.style.width = "200px";
	select.title = "Select the chart within the simfile that contains the steps for your edit.";

	for (let i = 0; i < charts.length; i++) {
		let st = (charts[i].stepsType === "dance-single") ? "Single" : "Double";

		let option = document.createElement("OPTION");
		option.value = i;
		option.text = `"${charts[i].chartName}" (${st} ${charts[i].difficulty} ${charts[i].meter})`;
		option.selected = true;  // The custom chart the user wants to use is most likely to be the last one in the list
		select.appendChild(option);
	}

	select.addEventListener("change", function() {
		for (let i = 0; i < SIMFILES.length; i++) {
			if (SIMFILES[i].editId !== editId) {
				continue;
			}
			let newIndex = select.selectedIndex;

			let difficulty = DIFFICULTY_NAMES_SM.indexOf(SIMFILES[i].charts[newIndex].difficulty);
			if (difficulty < 0 || difficulty > 4) {
				difficulty = 4;
			}

			let meter = SIMFILES[i].charts[newIndex].meter;
			if (meter < 0) { meter = 0; }
			if (meter > 20) { meter = 20; }

			document.getElementById("difficulty" + editId).selectedIndex = difficulty;
			document.getElementById("meter" + editId).selectedIndex = meter;

			let chartName = formatEditName(SIMFILES[i].charts[newIndex].chartName);
			document.getElementById("editname" + editId).value = chartName;
		}
	});

	return select;
}

// Create a difficulty-selection dropdown element using the DDR names (Beginner, Basic, Difficult, Expert, Challenge)
//
// Note that SM/SSC use different difficulty names (Beginner, Easy, Medium, Hard, Challenge), so we match on SM names but display DDR names
//
// difficulty: The name of a difficulty, as specified by an SM/SSC file. This difficulty will be selected, if possible
// editId: The unique identifier for this row/edit
function createDifficultySelect(difficulty, editId) {
	let select = document.createElement("SELECT");
	select.id = "difficulty" + editId;
	select.className = "difficultyselect";
	select.title = "Select the difficulty type of this edit.";

	if (!DIFFICULTY_NAMES_SM.includes(difficulty)) {
		difficulty = "Challenge";
	}

	for (let i = 0; i < DIFFICULTY_NAMES_SM.length; i++) {
		let option = document.createElement("OPTION");
		option.value = i;
		option.text = DIFFICULTY_NAMES_DDR[i];
		if (DIFFICULTY_NAMES_SM[i] === difficulty) {
			option.selected = true;
		}
		select.appendChild(option);
	}

	return select;
}

// Create a meter-selection dropdown element
//
// meter: The meter of a chart, as specified by an SM/SSC file. This meter will be selected, if possible
// editId: The unique identifier for this row/edit
function createMeterSelect(meter, editId) {
	let select = document.createElement("SELECT");
	select.id = "meter" + editId;
	select.className = "meterselect";
	select.title = "Select the numerical difficulty rating of this edit.";

	if (meter > 20) { meter = 20; }
	if (meter < 0) { meter = 0; }

	for (let i = 0; i <= 20; i++) {
		let option = document.createElement("OPTION");
		option.value = i;
		option.text = "" + i;
		if (i === meter) { option.selected = true; }
		select.appendChild(option);
	}

	return select;
}

// Create a dropdown element for selecting a comment to display beside the edit in-game
//
// which: If 0, the dropdown will contain the options for the first comment; otherwise, the dropdown will contain the options for the second comment
// editId: The unique identifier for this row/edit
function createCommentSelect(which, editId) {
	let select = document.createElement("SELECT");
	select.id = "comment" + (which === 0 ? "a" : "b") + editId;
	select.className = "commentselect";
	select.title = "Select an optional comment to display beside your edit in the game.";

	for (let i = 0; i < 16; i++) {
		let option = document.createElement("OPTION");
		option.value = i;
		option.text = which === 0 ? COMMENTS_A[i] : COMMENTS_B[i];
		if (i === 0) { option.selected = true; }
		select.appendChild(option);
	}

	return select;
}

// Remove an edit/row and update the state accordingly
//
// editId: The unique identifier for the row/edit to remove
function removeRow(editId) {
	// Remove the row from the UI
	let erow = document.getElementById("erow" + editId);
	if (erow.parentNode) {
		erow.parentNode.removeChild(erow);
	}
	// Remove the associated simfile from the stored list
	for (let i = 0; i < SIMFILES.length; i++) {
		if (SIMFILES[i].editId === editId) {
			SIMFILES.splice(i, 1);
			break;
		}
	}
	// Update the numerical labels for reach row in the UI
	for (let i = 0; i < SIMFILES.length; i++) {
		editId = SIMFILES[i].editId;
		document.getElementById("num" + editId).innerHTML = `${i + 1}.`;
	}

	clearErrors();
	updateButtons();
}

// Add a new row to the UI, containing options for selecting which chart to convert, setting the name/meter/difficulty of the chart, etc.
//
// sm: Data extracted from a simfile, which will populate the contents of this row
function addRow(sm) {
	if (SIMFILES.length >= MAX_FILES) {
		addError(0, FIELD_NONE, `Could not add ${sm.fileName}: Maximum files already added (${MAX_FILES})`, PREFIX_INFO);
		return;
	}
	let editId = sm.editId;

	SIMFILES.push(sm);

	let row = document.createElement("DIV");
	row.id = "erow" + editId;
	row.className = "row";
	document.getElementById("erows").appendChild(row);

	let num = document.createElement("SPAN");
	num.id = "num" + editId;
	num.className = "num";
	num.innerHTML = `${SIMFILES.length}.`;
	row.appendChild(num);

	let remove = document.createElement("BUTTON");
	remove.id = "remove" + editId;
	remove.className = "remove";
	remove.addEventListener("click", function(e) { removeRow(editId) });  // Do not bind sm to the closure
	remove.innerHTML = "Remove";
	remove.title = "Remove this file from the list of edits.";
	row.appendChild(remove);

	let fileName = document.createElement("SPAN");
	fileName.id = "filename" + editId;
	fileName.className = "filename";
	fileName.innerHTML = sm.fileName;
	fileName.title = sm.fileName;
	row.appendChild(fileName);

	let songSelect = createSongSelect(sm.songName, editId);
	row.appendChild(songSelect);

	let chartSelect = createChartSelect(sm.charts, editId);
	row.appendChild(chartSelect);

	let difficultytarget = sm.charts[chartSelect.options.selectedIndex].difficulty;
	let difficultyselect = createDifficultySelect(difficultytarget, editId);
	row.appendChild(difficultyselect);

	let meterTarget = sm.charts[chartSelect.options.selectedIndex].meter;
	let meterSelect = createMeterSelect(meterTarget, editId);
	row.appendChild(meterSelect);

	let editName = document.createElement("INPUT");
	editName.id = "editname" + editId;
	editName.className = "editname";
	editName.maxLength = 8;
	editName.value = formatEditName(sm.charts[chartSelect.options.selectedIndex].chartName);
	// TODO: There are several other characters that are acceptable here; I extracted the font image so I can add them at some point. For now, these are fine.
	editName.title = "Set a title for your edit.  Names can be up to 8 characters and can include capital letters, numbers, spaces, and the following special characters: .!@#$%&-_=+\\()";
	row.appendChild(editName);

	let commentSelect0 = createCommentSelect(0, editId);
	row.appendChild(commentSelect0);

	let commentSelect1 = createCommentSelect(1, editId);
	row.appendChild(commentSelect1);

	updateButtons();
}

// Read and process a file uploaded by the user and add it to the edit group
function uploadFile(file) {
	let reader = new FileReader();
	reader.onload = function(e) {
		let contents = e.target.result;
		let sm = readSimfile(file.name, contents);

		if (sm.charts.length === 0) {
			addError(0, FIELD_NONE, `Could not add ${file.name}: No charts found`, PREFIX_INFO);
			return;
		}

		addRow(sm);
	};
	reader.readAsText(file);
}

// Add files to the edit group from a drag operation or from the file select menu 
function uploadFiles(e) {
	clearErrors();
	let files = e.target.files || e.dataTransfer.files;
	for (let i = 0; i < files.length; i++) {
		uploadFile(files[i]);
	}
}

// Cancel the default behavior for some drag event
function cancelDefaultDrag(e) {
	e.stopPropagation();
	e.preventDefault();
}

// Allow the user to drag files onto the page to add them to the edit group. Multiple files can be selected/dragged at once
function documentDrop(e) {
	cancelDefaultDrag(e);
	uploadFiles(e);
}

// Create a file and prompt the user to download it
//
// content: Content of the file to be downloaded
// fileName: Name of the file to be downloaded
function downloadFile(content, fileName) {	
	let blob = new Blob([content], {type: "application/octet-stream"});
	if (window.navigator.msSaveOrOpenBlob) {
		window.navigator.msSaveBlob(blob, fileName);
	} else {
		let elem = window.document.createElement("a");
		elem.href = window.URL.createObjectURL(blob);
		elem.download = fileName;
		document.body.appendChild(elem);
		elem.click();
		document.body.removeChild(elem);
	}
}

// Try to build the edit group. If successful, prompt the user to download it
function createEditClick(e) {
	clearErrors();

	let editGroup = {
		region: document.getElementById("region").selectedIndex,
		edits: [],
	};

	for (let i = 0; i < SIMFILES.length; i++) {
		let editId = SIMFILES[i].editId;

		let songSelect = document.getElementById("song" + editId);
		let songId = songSelect.options[songSelect.selectedIndex].value;

		let chartSelect = document.getElementById("chart" + editId);
		let chartId = chartSelect.options[chartSelect.selectedIndex].value;
		let notes = SIMFILES[i].charts[chartId].notes;

		let stepsType = (SIMFILES[i].charts[chartId].stepsType === "dance-single") ? 0 : 2;

		let difficulty = document.getElementById("difficulty" + editId).selectedIndex;
		let meter = document.getElementById("meter" + editId).selectedIndex;
		let name = document.getElementById("editname" + editId).value.toUpperCase();  // No lower-case letters
		let commentA = document.getElementById("commenta" + editId).selectedIndex;
		let commentB = document.getElementById("commentb" + editId).selectedIndex;

		let edit = {
			editId: editId,
			songId: songId,
			stepsType: stepsType,
			difficulty: difficulty,
			meter: meter,
			name: name,
			commentA: commentA,
			commentB: commentB,
			notes: notes
		}
		editGroup.edits.push(edit);
	}

	let buf = createEditGroupBuf(editGroup);
	if (buf) {
		let fileName = "DDR_EDIT_X.DAT";
		if (editGroup.region === 0) fileName = "DDR_EDIT_J.DAT";
		else if (editGroup.region === 1) fileName = "DDR_EDIT_U.DAT";
		else if (editGroup.region === 2) fileName = "DDR_EDIT_E.DAT";
		else if (editGroup.region === 3) fileName = "DDR_EDIT_A.DAT";
		downloadFile(buf, fileName);
	}
}

// Show or hide the instructions
//
// isVisible: If true, show the instructions; if false, hide them
function instructionsShow(isVisible) {
	if (isVisible) {
		document.getElementById("instructions_link").innerHTML = "Click to hide instructions";
		document.getElementById("instructions").style.visibility = "visible";
	} else {
		document.getElementById("instructions_link").innerHTML = "Click to show instructions";
		document.getElementById("instructions").style.visibility = "hidden";
	}
}

// Toggle the instructions between invisible and visible
function instructionsToggle() {
	let isVisible = (document.getElementById("instructions").style.visibility === "visible");
	instructionsShow(!isVisible);
}

// Set the default state of the UI: Create the buttons, set up event handlers, and start with the instructions hidden
function start() {
	instructionsShow(false);
	document.getElementById("upload").addEventListener("change", uploadFiles)
	document.getElementById("cbutton").addEventListener("click", createEditClick);
	document.documentElement.addEventListener("dragover", cancelDefaultDrag, false);
	document.documentElement.addEventListener("dragleave", cancelDefaultDrag, false);
	document.documentElement.addEventListener("drop", documentDrop, false);
	updateButtons();
}
